package bitbake

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/intrik8-labs/smidr/internal/config"
)

type Generator struct {
	config   *config.Config
	buildDir string
}

func NewGenerator(cfg *config.Config, buildDir string) *Generator {
	return &Generator{
		config:   cfg,
		buildDir: buildDir,
	}
}

func (g *Generator) Generate() error {
	confDir := filepath.Join(g.buildDir, "conf")
	if err := os.MkdirAll(confDir, 0755); err != nil {
		return err
	}
	if err := g.generateLocalConf(confDir); err != nil {
		return err
	}
	// Generate bblayers.conf
	if err := g.generateBBLayersConf(confDir); err != nil {
		return fmt.Errorf("failed to generate bblayers.conf: %w", err)
	}

	// Generate custom image recipe if needed
	if len(g.config.Build.ExtraPackages) > 0 {
		if err := g.generateCustomImageRecipe(); err != nil {
			return fmt.Errorf("failed to generate custom image recipe: %w", err)
		}
	}

	return nil
}

func (g *Generator) generateLocalConf(confDir string) error {
	var sb strings.Builder
	sb.WriteString("# Auto-generated local.conf - DO NOT EDIT\n")
	sb.WriteString("# Generated by Smidr\n")
	sb.WriteString(fmt.Sprintf("# Project: %s\n", g.config.Name))
	sb.WriteString(fmt.Sprintf("# Description: %s\n\n", g.config.Description))

	// Machine configuration
	machine := g.config.Build.Machine
	if machine == "" {
		machine = g.config.Base.Machine
	}
	sb.WriteString(fmt.Sprintf("MACHINE = \"%s\"\n", machine))

	if g.config.Base.Distro != "" {
		sb.WriteString(fmt.Sprintf("DISTRO = \"%s\"\n", g.config.Base.Distro))
	}
	sb.WriteString("\n")

	// Build Parallelism
	threads := g.config.Build.BBNumberThreads
	if threads <= 0 {
		threads = 4 // default to 4 threads if not specified
	}
	sb.WriteString(fmt.Sprintf("BB_NUMBER_THREADS = \"%d\"\n", threads))
	parallelMake := g.config.Build.ParallelMake
	if parallelMake <= 0 {
		parallelMake = 4 // default to 4 if not specified
	}
	sb.WriteString(fmt.Sprintf("PARALLEL_MAKE = \"-j %d\"\n\n", parallelMake))

	sb.WriteString("\n")
	sb.WriteString("# Shared download and cache directories\n")
	sb.WriteString("DL_DIR = \"${TOPDIR}/../downloads\"\n")
	sb.WriteString("SSTATE_DIR = \"${TOPDIR}/../sstate-cache\"\n")
	sb.WriteString("TMP_DIR = \"${TOPDIR}/tmp\"\n")

	sb.WriteString("\n")
	sb.WriteString("# Package management\n")
	sb.WriteString("PACKAGE_CLASSES = \"package_rpm\"\n")

	sb.WriteString("\n")
	sb.WriteString("# Extra image features\n")
	sb.WriteString("EXTRA_IMAGE_FEATURES = \"debug-tweaks\"\n")

	sb.WriteString("\n")
	sb.WriteString("# Additional image features\n")
	sb.WriteString("USER_CLASSES = \"buildstats image-mklibs image-prelink\"\n")

	sb.WriteString("\n")
	sb.WriteString("# Disk space monitoring\n")
	sb.WriteString("BB_DISKMON_DIRS = \"\\\n")
	sb.WriteString("    STOPTASKS,${TMPDIR},1G,100K \\\n")
	sb.WriteString("    STOPTASKS,${DL_DIR},1G,100K \\\n")
	sb.WriteString("    STOPTASKS,${SSTATE_DIR},1G,100K \\\n")
	sb.WriteString("    STOPTASKS,/tmp,100M,100K \\\n")
	sb.WriteString("    ABORT,${TMPDIR},100M,1K \\\n")
	sb.WriteString("    ABORT,${DL_DIR},100M,1K \\\n")
	sb.WriteString("    ABORT,${SSTATE_DIR},100M,1K \\\n")
	sb.WriteString("    ABORT,/tmp,10M,1K\"\n")

	sb.WriteString("\n")
	sb.WriteString("# Hash equivalence and shared state\n")
	sb.WriteString("BB_HASHSERVE = \"auto\"\n")
	sb.WriteString("BB_SIGNATURE_HANDLER = \"OEEquivHash\"\n")
	sb.WriteString("\n")
	// Extra packages
	if len(g.config.Build.ExtraPackages) > 0 {
		packages := strings.Join(g.config.Build.ExtraPackages, " ")
		sb.WriteString(fmt.Sprintf("IMAGE_INSTALL:append = \" %s\"\n", packages))
	}

	sb.WriteString("\n")
	sb.WriteString("# Accept licenses\n")
	sb.WriteString("LICENSE_FLAGS_ACCEPTED = \"commercial\"\n")

	sb.WriteString("\n")

	// Package Management
	sb.WriteString("PACKAGE_CLASSES = \"package_rpm\"\n")
	sb.WriteString("EXTRA_IMAGE_FEATURES = \"debug-tweaks \"\n")

	sb.WriteString("\n")

	sb.WriteString("# User and hostname configuration\n")
	sb.WriteString("USER_CLASSES ?= \"buildstats\"\n")
	sb.WriteString("\n")
	sb.WriteString("# Smidr metadata\n")
	sb.WriteString(fmt.Sprintf("SMIDR_PROJECT_NAME = \"%s\"\n", g.config.Name))
	sb.WriteString(fmt.Sprintf("SMIDR_BUILD_TIME = \"%s\"\n", time.Now().Format(time.RFC3339)))
	localConfPath := filepath.Join(confDir, "local.conf")
	return os.WriteFile(localConfPath, []byte(sb.String()), 0644)
}

func (g *Generator) generateBBLayersConf(confDir string) error {
	var sb strings.Builder
	sb.WriteString(`# Auto-generated bblayers.conf - DO NOT EDIT\n`)
	sb.WriteString(`# Generated by Smidr\n`)
	sb.WriteString(fmt.Sprintf("# Project: %s\n", g.config.Name))
	sb.WriteString(fmt.Sprintf("# Description: %s\n\n", g.config.Description))

	sb.WriteString("BBPATH := \"${TOPDIR}\"\n")
	sb.WriteString("BBFILES ?= \"\"\n")
	sb.WriteString("BBLAYERS ?= \" \\\n")
	for _, layer := range g.config.Layers {
		layerPath := g.getLayerPath(layer)
		sb.WriteString(fmt.Sprintf("  %s \\\n", layerPath))
	}
	sb.WriteString("\"\n")
	localConfPath := filepath.Join(confDir, "bblayers.conf")
	return os.WriteFile(localConfPath, []byte(sb.String()), 0644)
}

func (g *Generator) getLayerPath(layer config.Layer) string {
	if layer.Path != "" {
		return filepath.Join("${TOPDIR}/../layers", layer.Name)
	}
	// Git layer - assume all code is cloned into the sources directory
	return filepath.Join("${TOPDIR}/../sources", layer.Name)
}

func (g *Generator) generateCustomImageRecipe() error {
	recipesDir := filepath.Join(g.buildDir, "../meta-smidr-custom/recipes-core/images")
	if err := os.MkdirAll(recipesDir, 0755); err != nil {
		return err
	}

	var sb strings.Builder

	sb.WriteString("# Generated by Smidr\n")
	sb.WriteString(fmt.Sprintf("SUMMARY = \"%s\"\n", g.config.Description))
	sb.WriteString(fmt.Sprintf("DESCRIPTION = \"%s - Built with Smidr\"\n\n", g.config.Name))

	// Inherit from base image
	baseImage := g.config.Build.Image
	if baseImage == "" {
		baseImage = "core-image-minimal"
	}
	sb.WriteString(fmt.Sprintf("require recipes-core/images/%s.bb\n\n", baseImage))

	// Add extra packages
	if len(g.config.Build.ExtraPackages) > 0 {
		sb.WriteString("IMAGE_INSTALL += \" \\\n")
		for _, pkg := range g.config.Build.ExtraPackages {
			sb.WriteString(fmt.Sprintf("    %s \\\n", pkg))
		}
		sb.WriteString("\"\n")
	}

	// Write recipe
	recipePath := filepath.Join(recipesDir, "smidr-custom-image.bb")
	return os.WriteFile(recipePath, []byte(sb.String()), 0644)
}

// GetBitBakeCommand returns the bitbake command to run
func (g *Generator) GetBitBakeCommand() string {
	imageName := "smidr-custom-image"
	if len(g.config.Build.ExtraPackages) == 0 {
		imageName = g.config.Build.Image
	}
	return fmt.Sprintf("bitbake %s", imageName)
}
