package bitbake

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/intrik8-labs/smidr/internal/config"
)

type Generator struct {
	config   *config.Config
	buildDir string
}

func NewGenerator(cfg *config.Config, buildDir string) *Generator {
	return &Generator{
		config:   cfg,
		buildDir: buildDir,
	}
}

func (g *Generator) Generate() error {
	// Determine project root (parent of buildDir) and create conf directory there
	projectRoot := filepath.Dir(g.buildDir)
	rootConfDir := filepath.Join(projectRoot, "conf")
	if err := os.MkdirAll(rootConfDir, 0755); err != nil {
		return err
	}

	// Generate local.conf in root conf directory
	if err := g.generateLocalConf(rootConfDir); err != nil {
		return err
	}

	// Generate bblayers.conf in root conf directory
	if err := g.generateBBLayersConf(rootConfDir); err != nil {
		return fmt.Errorf("failed to generate bblayers.conf: %w", err)
	}

	// Generate custom image recipe if needed
	if len(g.config.Build.ExtraPackages) > 0 {
		if err := g.generateCustomImageRecipe(); err != nil {
			return fmt.Errorf("failed to generate custom image recipe: %w", err)
		}
	}

	return nil
}

func (g *Generator) generateLocalConf(confDir string) error {
	var sb strings.Builder
	sb.WriteString("# Auto-generated local.conf - DO NOT EDIT\n")
	sb.WriteString("# Generated by Smidr\n")
	sb.WriteString(fmt.Sprintf("# Project: %s\n", g.config.Name))
	sb.WriteString(fmt.Sprintf("# Description: %s\n\n", g.config.Description))

	// Machine configuration
	machine := g.config.Build.Machine
	if machine == "" {
		machine = g.config.Base.Machine
	}
	sb.WriteString(fmt.Sprintf("MACHINE = \"%s\"\n", machine))

	if g.config.Base.Distro != "" {
		sb.WriteString(fmt.Sprintf("DISTRO = \"%s\"\n", g.config.Base.Distro))
	}
	sb.WriteString("\n")

	// Build Parallelism
	threads := g.config.Build.BBNumberThreads
	if threads <= 0 {
		threads = 4 // default to 4 threads if not specified
	}
	sb.WriteString(fmt.Sprintf("BB_NUMBER_THREADS = \"%d\"\n", threads))
	parallelMake := g.config.Build.ParallelMake
	if parallelMake <= 0 {
		parallelMake = 4 // default to 4 if not specified
	}
	sb.WriteString(fmt.Sprintf("PARALLEL_MAKE = \"-j %d\"\n\n", parallelMake))

	sb.WriteString("\n")
	sb.WriteString("# Shared download and cache directories\n")

	// Use configured directories or defaults
	dlDir := "${TOPDIR}/../downloads"
	if g.config.Directories.Downloads != "" {
		dlDir = g.config.Directories.Downloads
	}
	sb.WriteString(fmt.Sprintf("DL_DIR = \"%s\"\n", dlDir))

	sstateDir := "${TOPDIR}/../sstate-cache"
	if g.config.Directories.SState != "" {
		sstateDir = g.config.Directories.SState
	}
	sb.WriteString(fmt.Sprintf("SSTATE_DIR = \"%s\"\n", sstateDir))

	tmpDir := "${TOPDIR}/tmp"
	if g.config.Directories.Tmp != "" {
		tmpDir = g.config.Directories.Tmp
	}
	sb.WriteString(fmt.Sprintf("TMP_DIR = \"%s\"\n", tmpDir))

	deployDir := "${TOPDIR}/deploy"
	if g.config.Directories.Deploy != "" {
		deployDir = g.config.Directories.Deploy
	}
	sb.WriteString(fmt.Sprintf("TI_COMMON_DEPLOY = \"%s\"\n", deployDir))
	sb.WriteString("DEPLOY_DIR = \"${TI_COMMON_DEPLOY}${@'' if d.getVar('BB_CURRENT_MC') == 'default' else '/${BB_CURRENT_MC}'}\"\n")

	sb.WriteString("\n")
	sb.WriteString("# Package management\n")
	packageClasses := "package_rpm"
	if g.config.Packages.Classes != "" {
		packageClasses = g.config.Packages.Classes
	}
	sb.WriteString(fmt.Sprintf("PACKAGE_CLASSES = \"%s\"\n", packageClasses))

	sb.WriteString("\n")
	sb.WriteString("# Extra image features\n")
	extraFeatures := "debug-tweaks"
	if len(g.config.Features.ExtraImageFeatures) > 0 {
		extraFeatures = strings.Join(g.config.Features.ExtraImageFeatures, " ")
	}
	sb.WriteString(fmt.Sprintf("EXTRA_IMAGE_FEATURES = \"%s\"\n", extraFeatures))

	sb.WriteString("\n")
	sb.WriteString("# Additional image features\n")
	userClasses := "buildstats"
	if len(g.config.Features.UserClasses) > 0 {
		userClasses = strings.Join(g.config.Features.UserClasses, " ")
	}
	sb.WriteString(fmt.Sprintf("USER_CLASSES = \"%s\"\n", userClasses))

	sb.WriteString("\n")
	sb.WriteString("# Disk space monitoring\n")
	sb.WriteString("BB_DISKMON_DIRS = \"\\\n")
	sb.WriteString("    STOPTASKS,${TMPDIR},1G,100K \\\n")
	sb.WriteString("    STOPTASKS,${DL_DIR},1G,100K \\\n")
	sb.WriteString("    STOPTASKS,${SSTATE_DIR},1G,100K \\\n")
	sb.WriteString("    STOPTASKS,/tmp,100M,100K \\\n")
	sb.WriteString("    HALT,${TMPDIR},100M,1K \\\n")
	sb.WriteString("    HALT,${DL_DIR},100M,1K \\\n")
	sb.WriteString("    HALT,${SSTATE_DIR},100M,1K \\\n")
	sb.WriteString("    HALT,/tmp,10M,1K\"\n")

	sb.WriteString("\n")
	sb.WriteString("# Hash equivalence and shared state\n")
	if g.config.Advanced.BBHashServe != "" {
		sb.WriteString(fmt.Sprintf("BB_HASHSERVE = \"%s\"\n", g.config.Advanced.BBHashServe))
	} else {
		sb.WriteString("BB_HASHSERVE = \"auto\"\n")
	}

	if g.config.Advanced.BBSignatureHandler != "" {
		sb.WriteString(fmt.Sprintf("BB_SIGNATURE_HANDLER = \"%s\"\n", g.config.Advanced.BBSignatureHandler))
	} else {
		sb.WriteString("BB_SIGNATURE_HANDLER = \"OEEquivHash\"\n")
	}
	sb.WriteString("\n")

	// QEMU configuration
	if g.config.Advanced.QemuSDL {
		sb.WriteString("PACKAGECONFIG:append = \" sdl\"\n")
	}
	if g.config.Advanced.QemuGTK {
		sb.WriteString("PACKAGECONFIG:append = \" gtk+\"\n")
	}

	// Extra packages
	if len(g.config.Build.ExtraPackages) > 0 {
		packages := strings.Join(g.config.Build.ExtraPackages, " ")
		sb.WriteString(fmt.Sprintf("IMAGE_INSTALL:append = \" %s\"\n", packages))
	}

	sb.WriteString("\n")
	sb.WriteString("# Accept licenses\n")
	if g.config.Advanced.LicenseFlags != "" {
		sb.WriteString(fmt.Sprintf("LICENSE_FLAGS_ACCEPTED = \"%s\"\n", g.config.Advanced.LicenseFlags))
	} else {
		sb.WriteString("LICENSE_FLAGS_ACCEPTED = \"commercial\"\n")
	}

	if g.config.Advanced.AcceptFSLEULA {
		sb.WriteString("ACCEPT_FSL_EULA = \"1\"\n")
	}

	sb.WriteString("\n")
	sb.WriteString("# Configuration version\n")
	if g.config.Advanced.ConfVersion != "" {
		sb.WriteString(fmt.Sprintf("CONF_VERSION = \"%s\"\n", g.config.Advanced.ConfVersion))
	} else {
		sb.WriteString("CONF_VERSION = \"2\"\n")
	}

	sb.WriteString("\n")
	sb.WriteString("# Inherit classes\n")
	if len(g.config.Features.InheritClasses) > 0 {
		for _, inheritClass := range g.config.Features.InheritClasses {
			sb.WriteString(fmt.Sprintf("INHERIT += \"%s\"\n", inheritClass))
		}
	} else {
		sb.WriteString("INHERIT += \"rm_work\"\n")
		sb.WriteString("INHERIT += \"toradex-mirrors toradex-sanity\"\n")
	}

	sb.WriteString("\n")
	sb.WriteString("# User and hostname configuration\n")
	sb.WriteString("USER_CLASSES ?= \"buildstats\"\n")
	sb.WriteString("\n")
	sb.WriteString("# Smidr metadata\n")
	sb.WriteString(fmt.Sprintf("SMIDR_PROJECT_NAME = \"%s\"\n", g.config.Name))
	sb.WriteString(fmt.Sprintf("SMIDR_BUILD_TIME = \"%s\"\n", time.Now().Format(time.RFC3339)))
	localConfPath := filepath.Join(confDir, "local.conf")
	return os.WriteFile(localConfPath, []byte(sb.String()), 0644)
}

func (g *Generator) generateBBLayersConf(confDir string) error {
	var sb strings.Builder
	sb.WriteString(`# Auto-generated bblayers.conf - DO NOT EDIT\n`)
	sb.WriteString(`# Generated by Smidr\n`)
	sb.WriteString(fmt.Sprintf("# Project: %s\n", g.config.Name))
	sb.WriteString(fmt.Sprintf("# Description: %s\n\n", g.config.Description))

	sb.WriteString("BBPATH := \"${TOPDIR}\"\n")
	sb.WriteString("BBFILES ?= \"\"\n")
	sb.WriteString("BBLAYERS ?= \" \\\n")
	for _, layer := range g.config.Layers {
		layerPath := g.getLayerPath(layer)
		sb.WriteString(fmt.Sprintf("  %s \\\n", layerPath))
	}
	sb.WriteString("\"\n")
	localConfPath := filepath.Join(confDir, "bblayers.conf")
	return os.WriteFile(localConfPath, []byte(sb.String()), 0644)
}

func (g *Generator) getLayerPath(layer config.Layer) string {
	if layer.Path != "" {
		return filepath.Join("${TOPDIR}/../layers", layer.Name)
	}
	// Git layer - assume all code is cloned into the sources directory
	return filepath.Join("${TOPDIR}/../sources", layer.Name)
}

func (g *Generator) generateCustomImageRecipe() error {
	recipesDir := filepath.Join(g.buildDir, "../meta-smidr-custom/recipes-core/images")
	if err := os.MkdirAll(recipesDir, 0755); err != nil {
		return err
	}

	var sb strings.Builder

	sb.WriteString("# Generated by Smidr\n")
	sb.WriteString(fmt.Sprintf("SUMMARY = \"%s\"\n", g.config.Description))
	sb.WriteString(fmt.Sprintf("DESCRIPTION = \"%s - Built with Smidr\"\n\n", g.config.Name))

	// Inherit from base image
	baseImage := g.config.Build.Image
	if baseImage == "" {
		baseImage = "core-image-minimal"
	}
	sb.WriteString(fmt.Sprintf("require recipes-core/images/%s.bb\n\n", baseImage))

	// Add extra packages
	if len(g.config.Build.ExtraPackages) > 0 {
		sb.WriteString("IMAGE_INSTALL += \" \\\n")
		for _, pkg := range g.config.Build.ExtraPackages {
			sb.WriteString(fmt.Sprintf("    %s \\\n", pkg))
		}
		sb.WriteString("\"\n")
	}

	// Write recipe
	recipePath := filepath.Join(recipesDir, "smidr-custom-image.bb")
	return os.WriteFile(recipePath, []byte(sb.String()), 0644)
}

// GetBitBakeCommand returns the bitbake command to run
func (g *Generator) GetBitBakeCommand() string {
	imageName := "smidr-custom-image"
	if len(g.config.Build.ExtraPackages) == 0 {
		imageName = g.config.Build.Image
	}
	return fmt.Sprintf("bitbake %s", imageName)
}
